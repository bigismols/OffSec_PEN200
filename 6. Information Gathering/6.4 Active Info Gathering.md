# DNS Enumeration

DNS is the distributed database which translates domain names to IP addresses in a hierarchical structure. Each type of server has different DNS records:
- **NS**: Nameserver records contain the name of the authoritative servers hosting the DNS records for a domain.
- **A**: Also known as a host record, the "_a record_" contains the IPv4 address of a hostname (such as www.megacorpone.com).
- **AAAA**: Also known as a quad A host record, the "_aaaa record_" contains the IPv6 address of a hostname (such as www.megacorpone.com).
- **MX**: Mail Exchange records contain the names of the servers responsible for handling email for the domain. A domain can contain multiple MX records.
- **PTR**: Pointer Records are used in reverse lookup zones and can find the records associated with an IP address.
- **CNAME**: Canonical Name Records are used to create aliases for other host records.
- **TXT**: Text records can contain any arbitrary data and be used for various purposes, such as domain ownership verification.

```host (-t mx/txt/etc.) [domain_name]```
	This finds the IP tied to the host. By default searches for A record but with the -t option, can specify certain records. Each server has different **priority numbers (MX servers).** Lower means used first.
	
	Error NXDOMAIN means DNS record does not exist for hostname.

`for ip in $(cat list.txt); do host $ip.megacorpone.com; done` 
	Assuming list.txt has list of subdomain names, then this bash one liner will try to resolve each hostname.

`for ip in $(seq 200 254); do host 51.222.169.$ip; done | grep -v "not found"`
	This one liner is to scan for a range of IP addresses! -v option here will print lines that **DON'T** have the string after.

`dnsrecon -d [domain_name] -t [type_of_enumeration] (-D [list_of_subdomain_strings])` 
	This is a python based script that brute-forces hostnames. Type of enum should be **brt** if list of subdomain strings is specified. If type is **std**, then it will scan normally for DNS records tied to the name.

`dnsenum [domain_name]`
	This enumerates for DNS records tied to name and also enumerates for IP ranges and reverse look-ups these addresses.

`nslookup -type=TXT [domain_name] (DNS_SERVER)`
	Windows tool to do reverse look up on domain names. Can specify type of record and also IP of DNS server to use. 

# Port Scanning

This may generate many logs and may trigger [_IDS/IPS_](https://www.barracuda.com/support/glossary/intrusion-detection-system). Thus, should be used with care. Full port scans can be done and may determine the scope of future scans. Nmap is less noisy than [_MASSCAN_](https://tools.kali.org/information-gathering/masscan) and [_RustScan_](https://rustscan.github.io/RustScan/) because it uses traffic rate limits.

`nc -nvv -w 1 -z 192.168.50.152 3388-3390` 
	-w for timeout and -z for no IO mode which is used for scanning instead of sending data. based on whether connection refused or not can see if port is open (TCP). These can be further examined with WireShark.
	
	If we use -u, will UDP scan instead.

`sudo iptables -I INPUT 1 -s 192.168.50.149 -j ACCEPT \ sudo iptables -I OUTPUT 1 -d 192.168.50.149 -j ACCEPT \ sudo iptables -Z`
	iptables is how we configure fire wall rules. `-I` option to insert a new rule into a given chain, which in this case includes both the `INPUT` (Inbound) and `OUTPUT` (Outbound) chains, followed by the rule number. We can use `-s` to specify a source IP address, `-d` to specify a destination IP address, and `-j` to `ACCEPT` the traffic. Finally, we'll use the `-Z` option to zero the packet and byte counters in all chains (clears the "history").

`sudo iptables -vn -L`
	`-v` option to add some verbosity to our output, `-n` to enable numeric output, and `-L` to list the rules present in all chains.

## Nmap Commands and Options

`sudo nmap -sT -sCV -T4 -p- [ip_address]`
	Good 1-liner for nmap full port scan. If no port range specified, will scan 1000 most common ports.

**Useful Options for Nmap**:
- `-sU`: UDP scanning
- `-Pn`: disables ping scan, assumes host is up
- `-sn`: disables port scan, checks if host/s are up.
- `-sS`: stealth SYN scanning, faster, more efficient
- `-A`: for aggressive scan
- `--top-ports=[number]`: scans top 10 ports
	"Top" ports in nmap are determined by the `/usr/share/nmap/nmap-services` file. Uses three whitespace-separated columns, 1st is name of service, 2nd is port number and protocol and 3rd is "[_port frequency_](https://nmap.org/book/nmap-services.html)". 
- `-O` : to determine scan for OS, not always 100% accurate.
- `--osscan-guess`: to more aggressively scan for OS.
- `--script [script_name]`: to use a script under `/usr/share/nmap/scripts`. `nmap --script-help [script_name]` to see details about the script.

## Windows Scanning (w/ Powershell)

`Test-NetConnection -Port 445 192.168.50.151` 
	Function that uses ICMP and TCP scan to check if host is up and if port is open.

`1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.50.151", $_)) "TCP port $_ is open"} 2>$null`
	Powershell one-liner to scan first 1024 ports on target machine. Does so by instantiating a TcpClient Socket object .

